I 树
1 对二叉树的各种遍历操作
	一般的前中后三种遍历方式
	后序遍历的修改，用于查询二叉树是否是镜像的 ; 左右中 右左中
	中序遍历的修改，对于二叉搜索树，可以从大到小输出; 左中右  右中左

II 二叉树的构建
	以前序中序来进行二叉树的构建
	直接给定一个数字n,构建出由1,..,n 组成的序列所能构造的所有二叉树搜索树



437 路径总和III  //没参考
此题需要考虑
	1> 树中存在负数的情况
	2> 存在子路径，所以从选定节点向下遍历时，一定要遍历到根节点，每遍历一个节点，进行累加。当调用返回时，需要判断当前节点的累加值和sum的值是否一致
	比如路径1 -2 1 -1 ，sum=-1，路径一:1 -2 1 -1  路径二:1 -2 ,路径二就是路径一的子路径。    


112 路径总和  //参考别人，主要是条件判断部分
	此道题目需要注意，是从根节点到叶子节点，也就是说只有当节点的左右子树都为NULL,并且当前的累加和为给定的值时，才返回true. 




007 重建二叉树 //递归终止条件，参考剑指 offer
	递归过程与前序对应
	1> 创建节点，节点值为rootkey,节点为root
	2> 判断该节点是否没有子树，如果没有，则直接返回
	3> 根据rootkey 将inOrder 拆分为left,right,然后根据left，将preOrder 拆分为两部分
	4> 根据拆分的结果继续递归


1367 二叉树中的列表 [没有参考]
	[二叉树的遍历]
	此题和437 112 是类似的，都是对二叉树进行遍历，然后每遍历到一个节点，就从这个节点开始递归查找。 


101 对称二叉树 [没有参考]
	[二叉树的遍历]
	主要是对后序遍历的修改，后序遍历的顺序是 左右中,而如果一棵二叉树是对称的，那么使用左右中和右左中进行遍历时，结果是一样的。 


951 翻转二叉树 [没有参考]
	[二叉树的遍历]
	不需要先将二叉树进行翻转，然后再一一进行比对。也就是不需要修改二叉树的结构。
	只需要对这两棵二叉树同时进行遍历操作，如果root1的左等于root2的右，或者root1的右等于root2的左，这时候需要特殊处理。按照值一致的方向
进行遍历即可。对于其他的情况，按照一般的遍历方式即可[比如说前序遍历]。
	刚开始的时候，特殊处理的顺序搞错了。我先是判断它们的左子树是否一致[这个属于一般情况]，接着判断特殊情况[比如root1的左等于root2的右，
后者root1的右等于root2的左]。正确的方式是首先判断是否是特殊情况，否则其他的就按照一般(情况)的遍历方式进行遍历。  



590 N叉树的后序遍历 [没参考]
	和一般的二叉树的后序遍历是类似的，只是一般只有左右孩子，而这里的孩子有多个，所以需要通过一个for来遍历所有的孩子。

剑指 offer 68  二叉搜索树的最近公共祖先   [没参考]  
	基本的策略是是从下往上找。最开始想到的是先使用层次遍历，然后保存结果。然后根据层次遍历的结果由下往上获取节点，然后从这个节点开始进行搜索。
好来一想，可以使用后序遍历呀，从而就不需要进行层次遍历已经保存相应的层次遍历的结果。 
	而从某个节点进行向下遍历时，如果查询到p q ，说明就找到了公共节点，为什么呢？应为是从下往上进行遍历。所以第一次查询到有公共节点时，则
这个节点就是最近的公共节点。 
236 二叉树的最近公共祖先
	比较时，应该是查看节点的地址是否是一致而不是判断值是否一致。



面试题54 二叉树的第k大节点
	我觉得剑指offer 给出的答案有问题。
	好一点的方式是对中序进行修改，变成右中左来遍历。


654 最大二叉树 [参考别人]
	主要是不太确定，将新添加的节点是放置在左子树还是右子树中。
	其实，刚开始的思路是错误的，也就是说不是通过从左到右遍历数组，每遍历一个元素，就创建一个节点，然后将这个节点插入到tree 中。

	参考别人的思路: 数组的大小确定了查找的范围，从这个范围内获取最大值，然后将数组划分为两部分，分别是这个元素对应节点的左右子树。
然后继续递归。  

652 寻找重复的子树 [参考别人]
	这道题目考察的还是二叉树的遍历
	在遍历的过程中，保存每个节点作为子树的根节点时的遍历结果，并且使用map 来进行存储，因为如果树中有重复的子树，
则说明这棵树中，不同的节点作为子树的根节点，遍历的结果是一样的。
			1
		   / \
		  2   3
		 /    /\
		4    2  4
			/
		   4
	针对每一个节点的遍历结果
	4:4
	2:2 4 
	1:1 2 4 3 2 4 4
	3:3 2 4 4
	4:4
	2:2 4
	4:4
	可以看到，如果二叉树中有重复的子树，那么就会重复的结果。将这些结果以string 的形式保存在map<string,int> 中，int 表示的是string 出现的
次数。


998 最大二叉树 II [没参考]
	这道题目虽然没有参考别人，但是没有仔细想好之前就开始写代码，习惯很不好。 而完全抱着碰运气的心态看是否可以ac。 
	分析
	1> 根节点可能被替换掉，如果根节点被替换掉，那么原来的根节点需要作为新根节点的左子树。 
	2> 插入新的节点，只可能插入到根节点的右子树中，也就是如果从根节点开始，沿着右子树进行递归，递归到某个节点node存在三种情况
		2.1 这个节点node的值小于插入值，此时将这个节点值使用插入值进行替换，并保存节点值，标记为temp ,然后新建一个节点，
		存储的值为temp，这个新节点的左右子树分别指向 node 左右子树的指向，并且node的left 指向这个新节点，node 的right 指向NULL 
		2.2 node 的值大于 插入值，并且node 为null,则新建节点，然后让node->right 指向这个新建的节点
		2.3 node 的值大于 插入值，并且node 不为null,则继续沿着右子树继续递归


1315 祖父节点值为偶数的节点和 [没参考]
	二叉树的遍历
	每遍历到一个根节点，就对查看这个节点的孙子节点是否存在，如果有孙子节点，就对孙子节点进行累加。 


96 不同的二叉搜索树 [参考别人]
	动态规划，或者说是一道数学题，涉及到卡特兰数
	结题思路：假设n个节点存在二叉排序树的个数是G(n)，1为根节点，2为根节点，...，n为根节点，当1为根节点时，其左子树节点个数为0，右子树节点个数为n-1，同理当2为根节点时，其左子树节点个数为1，右子树节点为n-2，所以可得G(n) = G(0)*G(n-1)+G(1)*(n-2)+...+G(n-1) * G(0) 

95 不同的二叉搜索树 II 
	刚开始的思路:分别以1,2,....,n为根节点，然后选择之后，就将数组分成左右两部分，也就是分别作为左右子树。但问题是某一个数字作为根节点时，
它所能构成的二叉树方式有很多。但是，这样导致的结果是子节点也可以构建出很多种，但是根节点却只有一个。    
	而且，使用递归来解决这道题目是常规的思路 	

104 二叉树的最大深度
	二叉树的遍历 

222 完全二叉树的节点个数
	二叉树的遍历
	使用一般的二叉树的遍历也是可以解决的，但是最好利用完全二叉树的性质去做这道题目。

	另外的解题方式是利用完全二叉树的性质，也就是说如果在某个根节点的左右子树的深度相同，那么在最后一层，节点一定会出现在右子树中。如果左子树
的深度大于右子树的深度，最后一层的节点一定是出现在左子树中。

700 二叉搜索树中的搜索
	选择一种遍历方式，暴力求解。 
	题目给出的是二叉搜索树，所以是否可以使用二分查找去做。 

116 填充每个节点的下一个右侧节点指针
	基本思路是使用一个二维vector来存储层次遍历的结果，然后对每一层的结果的元素进行链接。 

	看到其他人的解题，主要是基于遍历的方法去做。
			1
		   / \
		  2   3
		 / \  /\
		4  5  6 7
	如果是基于遍历的方式去做，之前没有想到的原因是对于像节点 5,6这样的节点，如何将它接起来。 
	基于前序遍历，也就是说当遍历节点2的孩子时，此时2->3就已接好了，这样的话如果2的next不是null，那么就可以通过2来访问节点3，然后再访问
节点3的left，同时节点2可以访问自己的right，这样就将节点5,6给接好了。




117 填充每个节点的下一个右侧节点指针 II [参考别人，还需要再看]
	虽然使用116那样的思路也是可以做的，看了别人的，感觉比较好。



111 二叉树的最小深度[参考别人]
	题目要求的是从根节点到叶子节点的最短路径。 
	没做出来的原因是在取左右子树的最小值时，如何判断左右子树最终都是到达叶子节点的。 
	其他人给出的方案是，如果left or right 有一个为0，则表示该节点不是叶子节点,那么当前节点的高度就是left+right+1。


剑指 offer 26 树的子结构
	如果B为NULL，则B不是A的子结构。 

94 二叉树的中序遍历[参考别人] 
	借助stack来实现非递归遍历。


145 二叉树的后序遍历 [参考别人]
	注意 cur->right == r 这个条件的设置，比如说  [1,null,2,3] 这个例子，
	当对1进行出栈时，就需要用到这个条件，否则就陷入死循环

面试题 04.06 后继者 [没有参考]
	此题通过中序遍历来做。

	如果是二叉搜索树，是否可以使用二分查找来做。


103 二叉树的锯齿形层次遍历 [没有参考]
	

98 验证二叉搜索树 
	其实只需要在中序遍历的时，将上一次遍历的结果与当前的值进行比较即可。
	我的思路是将遍历结果存储在一个vector 中，然后对这个vector 中的结果进行判断。其实不需要vector的。




II 链表
	1> 利用快慢两个指针就可以求得链表的中间点。
	2> 对链表进行反转，整体反转，部分反转，包括两两反转，或者用户指定将链表划分为多段来对每段进行反转。

234 回文链表
	思路: 遍历链表，将遍历的结果使用一个deque来进行存储;然后分别取出dequeue的front以及back的值，然后进行比较，如果不相同则返回false。
直到deque为空，则返回true。

	[参考]利用快慢指针来获得链表的中间节点，然后将后半段的链表进行反转，接着分别从头节点和尾节点来遍历链表来判断值是否一致。 

203 移除链表元素
	我自己提交的代码，感觉编码风格很不好。 

	其他人给出的代码中，有使用哨兵节点去做。这样比较好。


237 删除链表中的节点
	题目很简单，这时题目理解起来有困难。


109 有序链表转化为二叉搜索树
	自己提交思路
	1> 将链表中的值存入到vector中;    //[额外增加了空间复杂度]
	2> 以vector 中的中间元素作为根节点，然后将vector中的元素划分为左右子树，并且每次从左右部分取最大值。


	参考其他人的做法，不需要额外的空间，每次找数组的中点，这个中间点就作为根节点，同时根据根节点将链表划分为左右两条独立的链表


面试题 02.02. 返回倒数第 k 个节点 [没有参考]
	思路:slow,fast 两个指针，fast 先走k个节点，然后两个指针同时移动，当fast移动到末尾时，slow 指向的就是待删除的接待你。
其实还需要一个prev，prev 指向的是slow的前一个节点，其初始值为NULL，后续在更新slow之前将slow 赋值给prev。


面试题 02.07. 链表相交
	思路:
		分别计算出两条链表的长度，以及差值;
		长的那条链表先走差值个节点，接着同时遍历两条链表，判断节点是否一致


328 奇偶链表 [没参考]
	思路: 两个指针，分别指向奇数节点和偶数节点，奇数节点的next使用偶数的next来更新，更新完成奇数指针的next，再使用奇数指针的next来更新
更新奇数指针自己，接着使用奇数的next来更新偶数的next，然后使用偶数的next来更新偶数自身。 


24 两两交换链表中的节点   
	刚开始的思路是:设置两个指针p1 & p2，将p1和p2指向的内容进行反向，然后将p1 p2 同时向后移动，也就是两个一组进行反向，但是组与组之前的
衔接没有处理好。 后面又写了一下，感觉代码写的不是很简洁。


25 K个一组翻转链表[难度比较大]





83 删除排序链表中的重复元素[没有参考]
	无论如何，链表的头节点是不会删除的，也就是说头节点是不会改变的。 

	在代码中，需要对循环内部的pNext 是否为NULL来进行判断。



82 删除排序链表中的重复元素 II [没有元素]
	链表的头节点可能会变化，比较好的处理方式是使用哨兵节点。
	
141 环形链表 [没有参考]
	判断链表中有无环，使用快慢指针，如果两个指针可以相遇，那么就说明有环，否则没有环。

142 环形链表 
	很久没有写，忘记了。当判断了链表中有环，已经环的大小时，两个指针p1,p2都是从head 开始前进。假设p1先走环大小的节点个数，
然后p1 和 p2 一起走。 每次只走一个节点。 
	写代码时，p2被设置环内的节点，然后p1先走环大小的节点数，接着然后p2每次走两个节点，p1每次走1个节点。 这时错误的。 


2 两数相加 [没有参考]
	做的时候花的时间比较长。
	基本思路是选择较长的链表，然后将数累加到这个链表中，累加是从左到右进行累加。最终可能需要新创建一个节点来存储最高位的进位。 
	  

445 两数相加 II [没有参考]
	基于递归求解
	由于两个链表的长短可能不一致，所以事先需要先确定好哪条链表比较长，同时确定长度的差值，在递归时候，如果长度的差值没有
减小到0，则只有长的链表递归，而短的链表仍然保持在头节点。只有当长度差减小到0，则两条链表同时递归，这样它们可以同时达到链表
的末尾，而递归的返回值是上一级的进位值。


160 相交链表 [没有参考]

1290 二进制链表转整数 
	越靠近链表的尾部，表示的越是低位。所以需要借助栈来完成，比较容易想到的就是递归。 
	但是也可以从前往后计算的，也就是说
	ListNOde * cur = head;
	int res = 0;
	while(cur)
	{
		res = res * 2 + cur->val;
		cur = cur->next;
	}
	也就是说越靠近链表头部，它乘以2(左移)的次数越多。


206 反转链表 [没参考]

92 反转链表 II [没有参考]  这道题目还是比较有代表性的
	1->2->3->4->5->6->NULL 
	这里也是使用到了哨兵节点，一开始错误的认为头节点不会改变，其实头节点是会改变的[也就是m设置为1]。而且我一开始将prev = NULL，
此时就出现段错误。 

	过程中cur & prev 两个指针不需要更新,但是cur指向的next 的元素会被更新，每次需要将这个元素提前，
	[sentry->next]->1->2->3->4->5->6->NULL
	prev 初始值设置为 sentry, cur设置为1，也就是头节点。 
	假设m = 2，n = 4。所以第一次执行后，链表变成 
	[sentry->next]->1->3->2->4->5->6->NULL 此时prev 还是指向1，cur 还是指向2。 
	第二次
	[sentry->next]->1->4->3->2->5->6->NULL 此时prev 还是指向1，cur 还是指向2。  
	...

876 链表中间节点 [没参考]


1019 链表中的下一个更大节点 [参考别人]
	刚开始审题错误，误以为后续的一个最大值，其实应该是后续第一个大于当前值的值。

	暂时只是想到 O(n^2) 复杂度的方法，也就是说每遍历一个节点，就从这个节点往下搜寻，找到第一个大于当前值的元素。最好的情况是升序，也就是下一个元素就大于当前元素。
而最坏的情况是降序，每次都遍历到链表的尾端。


	这道题目其实开可以使用动态规划去做的。

19 删除链表的倒数第N个节点[没有参考]
	由于头节点可能被删除，所以这里使用哨兵节点。





III  数组
二分查找
	33 搜索旋转排序数组
	思路是有的，但是写的代码总是不能完全的通过测试用例。 还要再看。


	21 合并两个有序链表 [没参考]
	主要考虑当两个链表中有节点值是相同的情况，防止在比较的过程中遗漏相同节点值的节点。



IV 队列





V 栈
	394 字符串解码 [参考别人]
	这道题目比较好，需要再看

	150 逆波兰表达式求值 [参考别人]
	这道题目其实是比较简单的

	224 基本计算器[参考别人]
	注意这里是没有 *  / 操作的。不知道该如何来处理() ,也就是 1+(3-2) 和 1+3-2 它们的计算结果是相同的，但是处理的顺序。

	第二次做时的问题就是，为什么如果当前是 ）时，还需要再做一次出栈进行计算操作。比如如下的计算： 
	"(1+(4+5+2)-3)+(6+8)" 
	前面括号的计算结果是 9 后面的结果是 14，但是到最后一个字符 ) 时，将 (出栈，但是符号栈中还有一个+，用于将9 + 14，
	由于此时字符串已经遍历结束，所以执行就退出了。所以得到数字栈中有两个元素 9 14，栈顶元素是14，符号栈中一个元素，
	栈顶是+号。

	227 基本计算器 II [参考别人]
	注意求解的表达式中有空格的情形。如果当前的操作符号是 + or - ,那么是不可以直接去计算值的，因为下一个可能是 * or / ，比如说1 + 2 * 3 这个
表达式，不能直接计算 1+2 ,得先计算2 * 3。刚开始是使用 i+1 来判断下一个操作符是否是乘除，但是就有空格的话就不好判断。 
参考比人的思路，如果出现 + - ，就先不计算，直接压栈，等到遍历字符串结束后，两个栈中还有内容。所以就需要再去处理一下，直到符号栈为空为止。
但是这样又会有一个问题，比如说 1-1+1，就会逆序计算，也就是先计算 1+1 ,然后再减去1。所以需要对两个栈进行逆序，


	946 验证栈序列 [没有参考]
	思路比较简单

	144 二叉树的前序遍历 [参考]
	使用辅助数据结构栈来完成，不使用递归遍历。

	225 使用队列实现栈 [没有参考]
	队列是先进先出的，所以出栈时，事先计算出当前队列的大小size ，然后出队size-1次，并且每次出队时，将出队的元素重新添加到队列尾部。
当完成size-1次的出队时，此时队头的元素就相当于是栈顶点的元素。

	1021 删除最外层的括号   [参考别人]
	这种思路比较好 [而且代码写的很简洁]
	对string 进行遍历，遍历时，如果当前是 ')' 则进行出栈，如果此时栈不为空，则说明当前的括号不是最外层的括号，所以需要保存这个括号。
	当前是'(' 则直接入栈即可。


	844 比较含退格的字符串[没有参考]
	需要注意，当栈为空，并且string 中有连续的 # 时，不要将#添加到栈中

	496 下一个更大的元素 I
	暴力解法: 比较直观的思路是在对num1中的每个元素val进行遍历时，找到num2 中元素的位置，然后查看其右侧是否有大于val的值。

	使用单调栈 [参考别人]
	nums1 nums2 
	先使用stack,来计算nums2中的下一个最大值，并将结果记录到map 中，这种对应关系是 当前值 ---> 下一个最大值
	对nums1 进行遍历，对遍历的元素查询 map 即可。 

	739 每日温度[参考思路，代码自己写]
	此题如果使用暴力解法，则超时。 
	借助辅助数据结构栈，栈中存储的是索引值
		1> 当栈为空时，直接将索引入栈；
		2> 栈不为空
			栈顶点元素[top]小于当前遍历的元素[i]，ret[top] = i - top ,出栈，重新判断是否成立，直到不成立或者栈空为止;
			栈顶点元素[top]大于当前遍历的元素[i]，直接入栈。 
	需要注意的地方是，设置 ret[top] = i - top ，而不是直接 ret.push_back(i - top)
	还有一点需要注意的是，当序列遍历完成之后，栈中的元素是大于1的。在我提交的代码中，ret 如果对应的索引没有设置，默认值为0，所以才没有出现问题。
如果后续不存在单于当前的值时，需要设置为-1，那么需要单独遍历栈，进行设置，直到将栈中的元素出栈完成。



VI 排序
	147 对链表进行插入排序 [没有参考]

	347 前 K 个高频元素 [参考别人]
	这道题目除了题目自身，还需要注意对一些容器的使用。 包括pair 优先队列 priority_queue 


VII  贪心算法
	455 分发饼干 [没有参考]
		排序，以低要求的先满足

	452 用最少数量的箭引爆气球
		关注一下使用 sort 对 vector<vector<int> > 进行排序

		有一点需要注意，需要更新区间 start end ,比如说排序后是这样的 
		1 10
		3 9
		4 11
		6 7
		6 9
		8 12
		9 12
		刚开始start = 1 ,end = 10，也就是在1到10之间射击都可以满足
		接着是 3 9,要使第一组和第二组都满足，那么只能在 3 到 9之间射击，所以start = 3 end = 9 
		接着4 11 ，start = 4,end = 9 
		接着 6 7 ,start = 6 ,end = 7 
		接着 6 9 ，start = 6,end = 7 
		接着 8 12，由于不在这个区间，所以需要新的箭，start = 8,end = 12 
		接着 9 12 ,start = 9 end = 12


VIII 动态规划
	121 买股票的最佳时机 [参考别人]
	使用动态规划 当前的最大收益 = max(前一天的最大收益,当前的价格-之前的最低价格)

	此题是否可以使用贪心算法

	122 买卖股票的最佳时机 [参考别人]
		贪心 & 动态规划 具体思路没有看懂



分治

堆 

数组 
	88 合并两个有序数组 [没有参考]
	将比较的数组从后往前填入nums1中，防止 nums1中的原本的数据被覆盖掉。

	方法二: 直接将nums2 中的数据填写到nums1 中，然后对nums1进行排序操作。

	1160 拼写单词 [没有参考]
		借助于hash table 



	26 删除排序数组中的重复项 [没有参考]

	刚开始使用迭代器，会失效
	迭代器失效
	int removeDuplicates(vector<int>& nums) {
        if(0 == nums.size() || 1 == nums.size())
        {
            return nums.size();
        }

        std::vector<int>::iterator cur = nums.begin();
        std::vector<int>::iterator next = cur+1;

        while(next != nums.end())
        {
            if((*next) == (*cur))
            {
                nums.erase(cur);
            }

            cur = next;
            next++;
        }
        return nums.size();
    }

    使用两个快慢索引，cur & next 如果[next] != [next] 同时更新next cur ,并且此时需要判断next 和 cur 是否一致，否则需要将[next] 拷贝给 [cur],
 到最后，cur 表示的就是删除后数组的长度。 
 	然后使用erase将 大于cur 长度部分删除。


 	674 最长连续递增序列 [没有参考]
 	不太确定是否可以使用动态规划去做


 	1299 将每个元素替换为右侧最大元素 [没有参考]
 	使用递归调用，递归的返回值是右侧的最大值

 	75 颜色分类
 	考察排序，由于数字在一定的范围之内，所以使用计数排序

 	注意迭代器的使用
 	fill(nums.being(),nums.begin()+val1,0) //将0 ~ (val1-1) 之间的值设置为0.

 	560 和为k的子数组  [参考别人]
 	刚开始的思路是，使用两个快慢指针，如果累加和小于k,end++ & sum+=nums[end],大于则start++ & sum-=nums[start],
 	但是由于数组不是排序数组，所以虽然当前的值是大于k的，但是如果下一个数是负数呢，就可以降下来，按时按照前面的处理方式，
 	就将 start++了。
 	2 3 6 -4
 	start = 0 end = 0 key = 7 ----> start = 0 end = 2时，sum = 11,sum > key ，所以sum -= nums[start++],
 	但是此时end++后，和就又可以被降下来。


 	O(n^2) 会超时，看了一种比较巧妙的方法，借助map,具体如下: 遍历数组，进行累加，每次累加将当前累加和作为key ,val++ ，表示出现过的次数
 	而当 sum - key 在哈希表中可以查询时，说明存在这个序列，和为key,
 	|------------------------|               
 			sum
 	0						 i
 	|--------------|
 			diff	
 	0              idx
 				   |---------|
 				   		key
 				   idx       i

 	也就是 [idx]+...+[i] 的和就是key。因为 [0]+.....+[idx] = diff 是确定的。

 	需要注意的是这种情况: 从[0]+......+[i]刚好是 key 的这种情况。


 	48 旋转图像 [参考别人]

 	1 两数之和 
 	暴力搜索的复杂度比较高 n^2
 	因为需要返回的是具体的位置，不能直接对数组排序，破坏原有的次序。

 	如果使用map 来存储数值 和 索引的映射关系，而且本身map 是排序的。但是这样有个问题，就是map 中不能保存重复的数。而排序是针对数值排序而不是针对索引。
 	其实使用multimap 即可。

 	4 寻找两个正序数组的中位数 [参考]
 	复杂度达不到要求
 	刚开始使用两个堆去做，其实不需要这么复杂，两个堆主要适合使用数据流去做。
 	其实，直接使用归并的方式，将两个数组合并为有序数组，然后获得中位数。 但是复杂度无法达到要求。

 	15 三数之和 [参考别人]
 	对于重复的情况 
 	假设排序之后的数组是 
 	-4 -1 -1 -1 0 1 2 2
 	0   1  2  3 4 5 6 7
 	当i = 1,left = i+1,right = 7,也就是 -1 -1 2 ,此时的累加和为0，如果仅仅是left++,right--。
 此时i =2,left = 3，right = 6，则的还是 -1 -1 2,所以结果就存在重复。 

 	上述说明的是left or right 重复的情况，还有一种是 i 重复的情况，假设排序之后的数组是
 	-4 -1 -1 0 1 2 
 	0   1  2 3 4 5 
 	i = 1,left = 2 ,right = 5,也就是 -1 -1 2，接着 left++,right--,得到i = 1,left = 3,right =4,对应的值为
 -1 0 1 ,累加和为0.
 	i=2时，left = 3 right =5,当right =4时，此时为 -1 0 1,与上述重复了。
 	所以i left right 都需要去除重复。


 	66 加一 [没有参考]

 	78 子集合 [参考别人]
 		使用DFS来做。
 		还是不是特别理解
 	
 	784 字母大小写全排列 [没有参考]
 		一开始的思路错误。

 	[78 784 这些题目可能与dfs 相关。]


 	56 合并区间   [没有参考]
 		感觉我的解法效率比较低，我是先排序，然后再遍历。

字符串
	344 反转字符串 [没有参考]

	541 反转字符串 [没有参考]
		注意迭代器的使用，如果对string 中的前面两个字符进行反转，
		reverse(str.being(),str.begin()+2) //注意，这里是+2,而不是+1.
		其实看对整个字符串进行反转也可以看出
		reverse(str.being(),str.end()); 
		而 str.end() 则是字符串最后一个字符的后一个位置。这个位置是不存放字符的

	557 反转字符串 [没有参考]

	58 最后一个单词的长度 [没有参考]

	151 翻转字符串里的单词 [没有参考]
	做了算是比较长的时间，比较琐碎
	基本流程
		1> 去除多余的空格
		2> 对字符串整体反转
		3> 对单个字符串进行反转

	刚开始，主要是对string 操作熟悉。
	string str1 = "hello";
	string str2; or string str2= "";
	如果使用 str2[0] = str1[0] 这样的赋值操作不成功。
	可以使用 str2 += str1[0] 
	看到别人使用 stringstream 来做，stringstream 不是很熟悉。


	709 转换成小写字母   [没有参考]

	521 最长特殊序列 I [没有参考]
	注意上面所说的最长
	其实这道题目就是比较字符串的长度。
	长度不相同，则返回长的，因为长的不可能是短的字串。
	长度相同，如果两个字符串不相同，则返回字符串的长度。

	415 字符串相加 [没有参考]

	917 仅仅反转字母 [没有参考]

	22 括号生成 [没有参考]
		使用递归
		递归终止条件是所有的符号都使用完了，就是说输入是n,总符号数就是 2*n 
		递归过程中需要记录的内容: 
			1> 当前(符号剩余个数 ,只有有剩余的情况下，才能继续push (
			2> 使用的(符号待配对的个数，比如(() 则待配对的(就是1，此时才能 push ) ,否则只能push ( 

	1189 "气球" 的最大值 [没有参考]
		使用map 来统计 b a l o n 出现的次数，并且对于 l o 需要除以2，并以最小的为准。

	824 山羊拉丁文 [没有做出来]

	13 罗马数字转整数 [没有参考]
  		主要需要关注 map & string 的使用。

  	12 整数转罗马数字 [参考别人]
  		一开始有个地方理解错了，比如说 2000 ,应该是 MM,而不是 MII，MII 表示的是1002。

  	38 外观数列 [没有参考]
  		这种题目虽然没有参考别人，但是感觉做的时候，很绕。

  	606 根据二叉树创建字符串 [没有参考]
  		题目理解的不是很好
  		如果一个节点有左右子树，那么左右子树需要分别使用括号括起来
  		如果一个节点只有左子树，那么右子树的括号就不需要了
  		如果一个节点只有右子树，左子树的括号必须加上

  	434 字符串中的单词数 [没有参考]


  	28 实现 strStr() [一般思路超时]
  		一般的实现会出现超时的问题，这道题目应该使用KMP去做，但是难度不应该是简单。

  	657 机器人能否回到原点 [没有参考]

  	3 无重复字符的最长字串 [参考剑指offer]
  		有点影响，但是还是没有做出来。
  		思路就是: 记录以某个字符为结束字符时的长度，注意这个长度不一定是这个字符串最大的长度。
  		比如 abcabcb 
  		比如说遍历到最后一个b,当前字符串的最大长度就是3，但是以字符b为结束字符时，无重复字符串的长度就是2.


  		刚开始并没先记录下当前遍历的字符最近出现的位置

  	8 字符串转换整数 (atoi)
  		函数返回值是 int,使用的是long 来存储计算结果。 
  		但是如果数值很大很大，那么在计算的过程中就会溢出，所以当计算出一个临时值时，就检查数值是否会溢出，如果溢出则终止计算，直接返回。

  	169 多数元素 [没有参考]
  		在改进的方法中，主要是对 prev 在什么位置进行更新存在一些问题，尝试了很多次。 


  	剑指offer 62,圆圈中最后剩下的数字  
  		给出的解答竟然超时。

  	46 全排列 [没有参考]


  	53 最大子序和 [没有参考]
  		我给出的算法复杂度是 O(n),题目的进阶版本是使用分治算法来做。



二分查找

	392 判断子序列 [没有参考]
	不确定为什么要分到 二分查找里面


	378 有序矩阵中第K小的元素 [参考别人]
	方法一

	方法二: 利用归并
	[注意 这里的emplace 的使用]

	刚开始没有想明白为什么需要借助 priority_queue，这里归并的体现是。当我们利用归并排序时，不是需要对两个有序数组进行合并形成一个有序
数组，有序数组还是保存到原数组中的，那么当k-1正好在本次合并后的区间范围之内，那么只要返回索引对应的元素即可
	比如start = 0 mid = 2 end = 4
	arr1 = [1 2 3]
	arr2 = [4 5]
	合并后就是 arr = 1 2 3 4 5,索引范围是start ~ end ,也即是0 ~ 4
	假设k=2 也就是找第二小的元素，而k是在上述的区间内的，所以直接返回 arr[1]即可。 
	此处，其实当确定好 arr[1] 时，即可返回。


	那这里为什么需要借助与priority_queue 呢。上述是对两个数组进行合并，但是此时由于是二维数组，需要对多个数组进行同时(注意是同时)合并。
	首先将第一个放置到priority_queue 中，第一列是对应每一行的最小值。 每次将队列中的最小值取出，并将这行元素的下一个值假如，反复，直到
	出队的元素和k一致，关于执行的次数是k-2次，因为是第k小，所以返回的是排序后的第k-1个元素，所以当k-2次执行完成之后，这个第k小的元素就在
	堆顶部。从而获得结果[可以看出每次的出队操作所形成的序列就是已经排序好的]

	方法三 [还需要再看]
	针对矩阵的特性，左上角为矩阵的最小值，右上角为矩阵的最大值。通过将两者的值进行平均，得到一个值将矩阵划分为左上和右下两部分。
	每次需要统计划分后的两半的计数，每次统计时，都是从左下角开始。

	当前的问题是 k 如何与 最终的统计计数对应起来。



	74 搜索二维矩阵[没有参考]
		这道题目在剑指 offer中有

		使用74给出的解法在240 也适用的。

		其实可以是利用二分查找来完成,这里每次搜索时，分别需要对水平和垂直两个方向进行搜索，只要有一个方向找到即可。举例来说： 
		[1,   4,  7, 11, 15]
  		[2,   5,  8, 12, 19]
  		[3,   6,  9, 16, 22]
  		[10, 13, 14, 17, 24]
  		第一次水平方向的搜索范围是 [1,   4,  7, 11, 15] ，对其使用二分。垂直方向就是 [15,19,22,24]，使用二分
  		第二次水平就是 2 5 8 12 ，垂直方向就是 12 16 17 。


  	69 x的平方根  [没有参考]
  	这道题目可以使用二分来做，但是需要考虑溢出。
  	刚开始是两个数字相乘，此时就是大概率溢出了。这时候就需要将mid设置为long long ，防止 mid*mid 溢出。[其实这样还是不能够解决问题，当数字非常大时，
  还是会出现溢出的问题。]

  	看到别人的一种解法是使用除法而不是使用乘法，这样其实就不需要将mid 设置为long long.start 和 end 在二分的过程中会互相靠拢，最终让它们的差值为1时
  跳出循环即可。
  	还有一点需要注意的是 如果 x/start 刚好等于start ，此时应该更新的是 start = mid。这里需要注意。

  	







其他
	7 整数反转
		刚开始想到的是使用递归去做，但是估计递归也做不出来。 
		两个方面: 考虑溢出，题目给出的是int,那么就使用一个更大的，比如long long，
		不需要递归。

	371 两整数之和[参考别人]
		此题按照剑指offer 的解法，如果是负数的话就会导致溢出。 
		这个和环境有关，我在mac & centos 中测试 
		int num = 0x80000000;
		num = num << 1; 
		没有出错，但是在leetcode 中就出现
		runtime error: left shift of negative value -2147483648 (solution.cpp)
SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:15:19
		这样的错误。 
		但是如果将上述修改为 num = (unsigned)num << 1;就不会有问题，并且执行结果是0.
		难道符号位不能移。


	50 Pow(x,n) [参考别人]
		这道题目没有做出来，最后提交的时候，超时。

		比如 int n = -2147483648
		unsigned int num;
		现在需要将 n 赋值给num，而num 得到的是一个正数。
		如果直接的做法为:
			num = (-n);
		这样是会导致溢出的。[ps 和num 没有什么关系，主要是 (-n) 这个操作。本地环境没有问题，主要是leetcode 上执行有问题。]
		一种解决方式是将 num 设置为 long long 。 也就是如下的这种方式: 
		long long int num = n;
		num = (-num);

	202 快乐数 [参考别人]
		首先快乐数具有的特性: 不是快乐数的数称为不快乐数（unhappy number），所有不快乐数的数位平方和计算，最後都会进入 
4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4 的循环中。也就是说，如果不是快乐数，那么就会构成一个环，对于环而言，就可以使用
快慢指针来对做。有点类似于链表中的环一样。 

		刚开始的思路是，不断的去求解，然后对求解的结果判断是否是1，但是这样对于不是快乐的数的话，就会出现死循环。






动态规划
	70 爬楼梯 [没有参考]

















