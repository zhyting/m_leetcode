I 树
1 对二叉树的各种遍历操作
	一般的前中后三种遍历方式
	后序遍历的修改，用于查询二叉树是否是镜像的 ; 左右中 右左中
	中序遍历的修改，对于二叉搜索树，可以从大到小输出; 左中右  右中左

II 二叉树的构建
	以前序中序来进行二叉树的构建
	直接给定一个数字n,构建出由1,..,n 组成的序列所能构造的所有二叉树搜索树



437 路径总和III  //没参考
此题需要考虑
	1> 树中存在负数的情况
	2> 存在子路径，所以从选定节点向下遍历时，一定要遍历到根节点，每遍历一个节点，进行累加。当调用返回时，需要判断当前节点的累加值和sum的值是否一致
	比如路径1 -2 1 -1 ，sum=-1，路径一:1 -2 1 -1  路径二:1 -2 ,路径二就是路径一的子路径。    


112 路径总和  //参考别人，主要是条件判断部分
	此道题目需要注意，是从根节点到叶子节点，也就是说只有当节点的左右子树都为NULL,并且当前的累加和为给定的值时，才返回true. 




007 重建二叉树 //递归终止条件，参考剑指 offer
	递归过程与前序对应
	1> 创建节点，节点值为rootkey,节点为root
	2> 判断该节点是否没有子树，如果没有，则直接返回
	3> 根据rootkey 将inOrder 拆分为left,right,然后根据left，将preOrder 拆分为两部分
	4> 根据拆分的结果继续递归


1367 二叉树中的列表 [没有参考]
	[二叉树的遍历]
	此题和437 112 是类似的，都是对二叉树进行遍历，然后每遍历到一个节点，就从这个节点开始递归查找。 


101 对称二叉树 [没有参考]
	[二叉树的遍历]
	主要是对后序遍历的修改，后序遍历的顺序是 左右中,而如果一棵二叉树是对称的，那么使用左右中和右左中进行遍历时，结果是一样的。 


951 翻转二叉树 [没有参考]
	[二叉树的遍历]
	不需要先将二叉树进行翻转，然后再一一进行比对。也就是不需要修改二叉树的结构。
	只需要对这两棵二叉树同时进行遍历操作，如果root1的左等于root2的右，或者root1的右等于root2的左，这时候需要特殊处理。按照值一致的方向
进行遍历即可。对于其他的情况，按照一般的遍历方式即可[比如说前序遍历]。
	刚开始的时候，特殊处理的顺序搞错了。我先是判断它们的左子树是否一致[这个属于一般情况]，接着判断特殊情况[比如root1的左等于root2的右，
后者root1的右等于root2的左]。正确的方式是首先判断是否是特殊情况，否则其他的就按照一般(情况)的遍历方式进行遍历。  



590 N叉树的后序遍历 [没参考]
	和一般的二叉树的后序遍历是类似的，只是一般只有左右孩子，而这里的孩子有多个，所以需要通过一个for来遍历所有的孩子。

面试题68  二叉搜索树的最近公共祖先   [没参考]  剑指 offer
	基本的策略是是从下往上找。最开始想到的是先使用层次遍历，然后保存结果。然后根据层次遍历的结果由下往上获取节点，然后从这个节点开始进行搜索。
好来一想，可以使用后序遍历呀，从而就不需要进行层次遍历已经保存相应的层次遍历的结果。 
	而从某个节点进行向下遍历时，如果查询到p q ，说明就找到了公共节点，为什么呢？应为是从下往上进行遍历。所以第一次查询到有公共节点时，则
这个节点就是最近的公共节点。 


面试题54 二叉树的第k大节点
	我觉得剑指offer 给出的答案有问题。
	好一点的方式是对中序进行修改，变成右中左来遍历。


654 最大二叉树 [参考别人]
	主要是不太确定，将新添加的节点是放置在左子树还是右子树中。
	其实，刚开始的思路是错误的，也就是说不是通过从左到右遍历数组，每遍历一个元素，就创建一个节点，然后将这个节点插入到tree 中。

	参考别人的思路: 数组的大小确定了查找的范围，从这个范围内获取最大值，然后将数组划分为两部分，分别是这个元素对应节点的左右子树。
然后继续递归。  

652 寻找重复的子树 [参考别人]
	这道题目考察的还是二叉树的遍历
	在遍历的过程中，保存每个节点作为子树的根节点时的遍历结果，并且使用map 来进行存储，因为如果树中有重复的子树，
则说明这棵树中，不同的节点作为子树的根节点，遍历的结果是一样的。
			1
		   / \
		  2   3
		 /    /\
		4    2  4
			/
		   4
	针对每一个节点的遍历结果
	4:4
	2:2 4 
	1:1 2 4 3 2 4 4
	3:3 2 4 4
	4:4
	2:2 4
	4:4
	可以看到，如果二叉树中有重复的子树，那么就会重复的结果。将这些结果以string 的形式保存在map<string,int> 中，int 表示的是string 出现的
次数。


998 最大二叉树 II [没参考]
	这道题目虽然没有参考别人，但是没有仔细想好之前就开始写代码，习惯很不好。 而完全抱着碰运气的心态看是否可以ac。 
	分析
	1> 根节点可能被替换掉，如果根节点被替换掉，那么原来的根节点需要作为新根节点的左子树。 
	2> 插入新的节点，只可能插入到根节点的右子树中，也就是如果从根节点开始，沿着右子树进行递归，递归到某个节点node存在三种情况
		2.1 这个节点node的值小于插入值，此时将这个节点值使用插入值进行替换，并保存节点值，标记为temp ,然后新建一个节点，
		存储的值为temp，这个新节点的左右子树分别指向 node 左右子树的指向，并且node的left 指向这个新节点，node 的right 指向NULL 
		2.2 node 的值大于 插入值，并且node 为null,则新建节点，然后让node->right 指向这个新建的节点
		2.3 node 的值大于 插入值，并且node 不为null,则继续沿着右子树继续递归


1315 祖父节点值为偶数的节点和 [没参考]
	二叉树的遍历
	每遍历到一个根节点，就对查看这个节点的孙子节点是否存在，如果有孙子节点，就对孙子节点进行累加。 


96 不同的二叉搜索树 [参考别人]
	动态规划，或者说是一道数学题，涉及到卡特兰数
	结题思路：假设n个节点存在二叉排序树的个数是G(n)，1为根节点，2为根节点，...，n为根节点，当1为根节点时，其左子树节点个数为0，右子树节点个数为n-1，同理当2为根节点时，其左子树节点个数为1，右子树节点为n-2，所以可得G(n) = G(0)*G(n-1)+G(1)*(n-2)+...+G(n-1) * G(0) 

95 不同的二叉搜索树 II 
	刚开始的思路:分别以1,2,....,n为根节点，然后选择之后，就将数组分成左右两部分，也就是分别作为左右子树。但问题是某一个数字作为根节点时，
它所能构成的二叉树方式有很多。但是，这样导致的结果是子节点也可以构建出很多种，但是根节点却只有一个。    
	而且，使用递归来解决这道题目是常规的思路 	

104 二叉树的最大深度
	二叉树的遍历 

222 完全二叉树的节点个数
	二叉树的遍历
	使用一般的二叉树的遍历也是可以解决的，但是最好利用完全二叉树的性质去做这道题目。

	另外的解题方式是利用完全二叉树的性质，也就是说如果在某个根节点的左右子树的深度相同，那么在最后一层，节点一定会出现在右子树中。如果左子树
的深度大于右子树的深度，最后一层的节点一定是出现在左子树中。

700 二叉搜索树中的搜索
	选择一种遍历方式，暴力求解。 
	题目给出的是二叉搜索树，所以是否可以使用二分查找去做。 

116 填充每个节点的下一个右侧节点指针
	基本思路是使用一个二维vector来存储层次遍历的结果，然后对每一层的结果的元素进行链接。 

	看到其他人的解题，主要是基于遍历的方法去做。
			1
		   / \
		  2   3
		 / \  /\
		4  5  6 7
	如果是基于遍历的方式去做，之前没有想到的原因是对于像节点 5,6这样的节点，如何将它接起来。 
	基于前序遍历，也就是说当遍历节点2的孩子时，此时2->3就已接好了，这样的话如果2的next不是null，那么就可以通过2来访问节点3，然后再访问
节点3的left，同时节点2可以访问自己的right，这样就将节点5,6给接好了。






















































